# 第一个程序
## 文本编辑器

只需要在代码编辑窗口中编写代码就可以完成 1 个程序的编写。每个窗口都对应 1 个代码文件，里面的内容就是你正在编写的代码。
你可以通过单击窗口顶部的文件名来重命名文件。

程序停止运行时，就可以在窗口中编写代码，像使用其他的文本编辑器一样。
单击窗口中的绿色运行按钮可以直接执行程序。
![](PlayButton50)

单击屏幕右上角的“+”按钮可以创建新的代码文件。
将一个窗口拖到另一个窗口上，两个窗口可以有序地堆放在一起。

在窗口中编写代码时，会弹出一个简单的代码补全窗口。
按 Tab 键可以补全代码。
使用方向键可以在代码补全窗口快速选择你想要输入的关键字、内置函数以及自定义函数等内容。
将鼠标移动到代码补全窗口的列表上时，可以快速展示对应的用法，这可以帮你快速理解关键字、内置函数以及自定义函数等内容的作用。

如果你是第一次编程，新手也可以快速上手。这些功能是逐步解锁的，相关知识不会一股脑地砸下来，让你手忙脚乱。
这款游戏中编程的语法也与 Python 相似，而 Python 是世界上使用最广泛的编程语言之一，所以学习它并不是在浪费时间。

如果已经了解 Python，恭喜！你可以快速跳过游戏的早期阶段，进入更有趣的部分。

目前，有两个函数可以用来操控无人机。

`harvest()`

和

`do_a_flip()`

这种写法就是调用这个函数。函数可以看作是一个可执行的命令，使用 `()` 圆括号来执行。

在窗口中输入这 2 个语句，然后单击运行按钮，就可以让无人机动起来，你自己试试看吧！

你可以把你编写的代码理解成是由单个语句组成的古诗，就像这样：

`床前明月光，
疑是地上霜。
举头望明月，
低头思故乡。`

这些语句就像古诗一样，从上到下依次执行，每一步都是你想让无人机做的事情：

`harvest()
do_a_flip()
harvest()`

## 科技树
收集草可获得干草。干草可以用来在科技树中解锁循环功能。点击右上角的按钮可打开科技树。

# 入门指南
这个窗口包含了游戏中所有内容。

拖动窗口的灰色部分可以移动窗口。
在窗口外任意处拖动可以移动游戏视角。

要开始编写代码了吗？请点击前往[第一个程序](docs/first_program.md)页面。

看见屏幕右上角的按钮了吗？将鼠标移到按钮上就可以看到按钮的作用了。其中一个按钮可以打开科技树！

# 自动解锁
你可以调用 `unlock()` 函数使科技树中的项目进行自动解锁，这可以实现完全自动化，解放双手！
例如，你可以调用 `unlock(Unlocks.Speed)` 和 `unlock(Unlocks.Expand)` 函数来解锁速度和扩张土地。

对科技树中的项目使用 `get_cost()` 函数，就可以获取该项目解锁或者升级所需的耗材数量，就像对植物或物品使用函数那样。
示例：
`get_cost(Unlocks.Loops)`
返回 `{Items.Hay:5}`

# 仙人掌
像其他植物一样，[仙人掌](objects/cactus)可以种植在耕过的土地上并收获。

然而，仙人掌大小不一，并有一种奇怪的秩序感。

如果收获一株完全成熟的仙人掌，并且所有相邻的仙人掌都已排序，则所有相邻的仙人掌也会以递归方式收获。

如果所有 `North`(上边) 和 `East`(右边) 方向的相邻仙人掌都完全成熟且尺寸大于或等于自身，并且所有 `South`(下边) 和 `West`(左边) 方向的相邻仙人掌都完全成熟且尺寸小于或等于自身，那么这个仙人掌就被认为是处于已排序状态。

当所有相邻的仙人掌都完全成熟并处于已排序状态时，可以触发“连锁收集”。
也就是说，如果一个方形区域的成熟仙人掌已经按大小排序，那么收获其中一株仙人掌时，会收获整个方形区域。

一株完全成熟的仙人掌如果未排序，会显示为棕色。一旦排序好，则会变回绿色。

你将获得的仙人掌数量等于所收获仙人掌数量的平方。因此，如果同时收获 `n` 个仙人掌，则将获得 `n**2` 个 `Items.Cactus`。

仙人掌的大小可以调用 `measure()` 函数获取。
获取的结果始终为以下数字之一：`0,1,2,3,4,5,6,7,8,9`。

你也可以向 `measure(direction)` 函数传入 1 个方向参数来获取无人机对应方向上的相邻地块的仙人掌大小。

调用 `swap()` 函数可将 1 株仙人掌与其任何方向的邻居交换位置。
`swap(direction)` 将无人机下方的物体与无人机 `direction` 方向 1 格处的物体交换位置。

## 示例
在这些网格中，所有的仙人掌都处于已排序状态，可以连锁收获整片田地：
`3 4 5    3 3 3    1 2 3    1 5 9
2 3 4    2 2 2    1 2 3    1 3 8
1 2 3    1 1 1    1 2 3    1 3 4`

在下面网格中，只有左下角的仙人掌处于已排序状态，这还无法触发“连锁收集”：
`1 5 3
4 9 7
3 3 2`

<spoiler=显示提示 1>
如果行已经排序，对列进行排序时，不会打乱行的顺序。
</spoiler>
<spoiler=显示提示 2>
如果不熟悉排序算法，不如“百度一下”，思考可以参照哪些算法来解决这个问题。当然，并不是所有算法都有效，因为你只能交换相邻的仙人掌。
</spoiler>

# 胡萝卜
调用 `plant(Entities.Carrot)` 函数可以种植胡萝卜。在种植胡萝卜之前你必须先耕地，只需调用 `till()` 函数即可耕地，将地块变为 `Grounds.Soil` 。再次调用 `till()` 则会将地块变回 `Grounds.Grassland`。


种植胡萝卜所需的耗材是干草和木材。请注意：调用 `plant(Entities.Carrot)` 函数种植胡萝卜时，这些耗材（干草和木材）会被消耗一定数量。

你可以在所有植物的[专属页面](objects/carrot)上查看所需的耗材数量。

# 耗材数量
所有的耗材数量都一个包含物品和数字的字典映射。

`get_cost()` 函数返回的值就是这样的一个字典：某种植物或某个科技树项目的耗材。

调用 `get_cost(Entities.Pumpkin)` 函数
会返回 `{Items.Carrot:1}`

向科技树中的各种项目添加第二个可选参数，就可以获取你想要的解锁等级对应的耗材数量。默认情况下为当前的解锁等级。

调用 `get_cost(Unlocks.Loops, 0)`
会返回 `{Items.Hay:5}`

如果科技树中的某些项目已经到达最高等级，调用 `get_cost()` 函数则返回 `None`。

使用示例如下：
`cost = get_cost(something)
for item in cost:
	amount_of_this_item_needed = cost[item]`

# 调试 2
当无人机速度太快，或者网格太大时，可能很难判断具体情况。

函数 `set_execution_speed()` 和 `set_world_size()` 便应运而生。
它们可用来减慢执行速度和缩小农场。

农场大小和执行速度将在执行结束时重置为默认值。

# 恐龙
恐龙是古老而奇伟的生物，可以养殖以获取远古骨头。

不幸的是，恐龙很久以前就灭绝了，所以我们现在最多只能打扮成恐龙。
为此，你收到了新的恐龙帽。

帽子可以用以下方式装备：
`change_hat(Hats.Dinosaur_Hat)`

很可惜，它看起来和广告上的不太一样……

如果装备了恐龙帽且有足够的仙人掌，则会自动购买一颗[苹果](objects/apple)并将其放置在无人机下方。
当无人机在苹果上方并再次移动时，便会吃掉苹果，同时尾巴增长一节。如果你还有足够的仙人掌，一颗新的苹果将被购买并放置在一个随机位置。
如果苹果想生成的位置已经种植了其他东西，则无法生成。

恐龙的尾巴会拖在无人机后面，填满无人机之前移动过的地块。如果无人机试图移动到尾巴上方，`move()` 将会失败并返回 `False`。
在移动过程中，尾巴的最后一节会移开，所以你可以移动到它原来的位置上。但是，如果尾巴填满了整个农场，你将无法再移动。所以你可以通过检查是否无法移动来判断尾巴是否已经长到最大。
戴着恐龙帽时，无人机无法越过农场边界到达另一边。

在苹果上使用 `measure()` 将返回下一个苹果的位置，形式为一个元组。

`next_x, next_y = measure()`

当通过装备不同的帽子再次卸下这顶帽子时，便会收获尾巴。
你将获得等于尾巴长度平方数量的骨头。因此，若尾巴长度为 `n`，则将获得 `n**2` 根 `Items.Bone`。
例如：
长度 1 => 1 根骨头
长度 2 => 4 根骨头
长度 3 => 9 根骨头
长度 4 => 16 根骨头
长度 16 => 256 根骨头
长度 100 => 10000 根骨头

恐龙帽非常重，所以装备后会使 `move()` 消耗 400 ticks 而不是 200。然而，每当你捡起一颗苹果，`move()` 使用的 ticks 数量便会减少 3%（向下取整），因为尾巴变长可以帮助移动。

以下循环打印出吃掉任意数量苹果后 `move()` 使用的 ticks 数量：

`ticks = 400
for i in range(100):
    print("吃掉 ", i, " 颗苹果后的 ticks: ", ticks)
    ticks -= ticks * 0.03 // 1`

你只有一顶恐龙帽，所以只有一架无人机可以佩戴它。

<spoiler=显示提示 1>如果始终沿着覆盖整个场地的同一路径移动，那么每次都能轻松地得到一条覆盖整个场地的尾巴蛇。虽然效率不高，但确实可行。
完全遍历一个非常大的农场可能需要很长时间，而且你实际上可能并不需要那么多骨头。不妨使用 `set_world_size()` 将农场改为更方便覆盖的大小。</spoiler>

# 扩张 1
<unlock=for>另请参阅[扩张_2](docs/unlocks/expand_2.md)

</unlock>你的农场变大了！无人机现在可以移动了，调用新的函数 `move()` 来移动无人机。`move()` 可以指定无人机移动的方向，为此还引入了四个新的常量：`North, East, South, West`，分别是“向上”、“向右”、“向下”和“向左”。


例如，`move(North)` 会将无人机向上移动 1 格。

如果超过农场边缘，无人机会回到起始方向的一边，并继续移动。
以下示例代码将使无人机一直向上移动，并在到达农场边缘时回到起点，并继续像上移动，直到程序停止运行：

`while True:
    move(North)`

# 恐龙
恐龙是古老而奇伟的生物，可以养殖以获取远古骨头。

不幸的是，恐龙很久以前就灭绝了，所以我们现在最多只能打扮成恐龙。
为此，你收到了新的恐龙帽。

帽子可以用以下方式装备：
`change_hat(Hats.Dinosaur_Hat)`

很可惜，它看起来和广告上的不太一样……

如果装备了恐龙帽且有足够的仙人掌，则会自动购买一颗[苹果](objects/apple)并将其放置在无人机下方。
当无人机在苹果上方并再次移动时，便会吃掉苹果，同时尾巴增长一节。如果你还有足够的仙人掌，一颗新的苹果将被购买并放置在一个随机位置。
如果苹果想生成的位置已经种植了其他东西，则无法生成。

恐龙的尾巴会拖在无人机后面，填满无人机之前移动过的地块。如果无人机试图移动到尾巴上方，`move()` 将会失败并返回 `False`。
在移动过程中，尾巴的最后一节会移开，所以你可以移动到它原来的位置上。但是，如果尾巴填满了整个农场，你将无法再移动。所以你可以通过检查是否无法移动来判断尾巴是否已经长到最大。
戴着恐龙帽时，无人机无法越过农场边界到达另一边。

在苹果上使用 `measure()` 将返回下一个苹果的位置，形式为一个元组。

`next_x, next_y = measure()`

当通过装备不同的帽子再次卸下这顶帽子时，便会收获尾巴。
你将获得等于尾巴长度平方数量的骨头。因此，若尾巴长度为 `n`，则将获得 `n**2` 根 `Items.Bone`。
例如：
长度 1 => 1 根骨头
长度 2 => 4 根骨头
长度 3 => 9 根骨头
长度 4 => 16 根骨头
长度 16 => 256 根骨头
长度 100 => 10000 根骨头

恐龙帽非常重，所以装备后会使 `move()` 消耗 400 ticks 而不是 200。然而，每当你捡起一颗苹果，`move()` 使用的 ticks 数量便会减少 3%（向下取整），因为尾巴变长可以帮助移动。

以下循环打印出吃掉任意数量苹果后 `move()` 使用的 ticks 数量：

`ticks = 400
for i in range(100):
    print("吃掉 ", i, " 颗苹果后的 ticks: ", ticks)
    ticks -= ticks * 0.03 // 1`

你只有一顶恐龙帽，所以只有一架无人机可以佩戴它。

<spoiler=显示提示 1>如果始终沿着覆盖整个场地的同一路径移动，那么每次都能轻松地得到一条覆盖整个场地的尾巴蛇。虽然效率不高，但确实可行。
完全遍历一个非常大的农场可能需要很长时间，而且你实际上可能并不需要那么多骨头。不妨使用 `set_world_size()` 将农场改为更方便覆盖的大小。</spoiler>

# 扩张 1
<unlock=for>另请参阅[扩张_2](docs/unlocks/expand_2.md)

</unlock>你的农场变大了！无人机现在可以移动了，调用新的函数 `move()` 来移动无人机。`move()` 可以指定无人机移动的方向，为此还引入了四个新的常量：`North, East, South, West`，分别是“向上”、“向右”、“向下”和“向左”。


例如，`move(North)` 会将无人机向上移动 1 格。

如果超过农场边缘，无人机会回到起始方向的一边，并继续移动。
以下示例代码将使无人机一直向上移动，并在到达农场边缘时回到起点，并继续像上移动，直到程序停止运行：

`while True:
    move(North)`

# 恐龙
恐龙是古老而奇伟的生物，可以养殖以获取远古骨头。

不幸的是，恐龙很久以前就灭绝了，所以我们现在最多只能打扮成恐龙。
为此，你收到了新的恐龙帽。

帽子可以用以下方式装备：
`change_hat(Hats.Dinosaur_Hat)`

很可惜，它看起来和广告上的不太一样……

如果装备了恐龙帽且有足够的仙人掌，则会自动购买一颗[苹果](objects/apple)并将其放置在无人机下方。
当无人机在苹果上方并再次移动时，便会吃掉苹果，同时尾巴增长一节。如果你还有足够的仙人掌，一颗新的苹果将被购买并放置在一个随机位置。
如果苹果想生成的位置已经种植了其他东西，则无法生成。

恐龙的尾巴会拖在无人机后面，填满无人机之前移动过的地块。如果无人机试图移动到尾巴上方，`move()` 将会失败并返回 `False`。
在移动过程中，尾巴的最后一节会移开，所以你可以移动到它原来的位置上。但是，如果尾巴填满了整个农场，你将无法再移动。所以你可以通过检查是否无法移动来判断尾巴是否已经长到最大。
戴着恐龙帽时，无人机无法越过农场边界到达另一边。

在苹果上使用 `measure()` 将返回下一个苹果的位置，形式为一个元组。

`next_x, next_y = measure()`

当通过装备不同的帽子再次卸下这顶帽子时，便会收获尾巴。
你将获得等于尾巴长度平方数量的骨头。因此，若尾巴长度为 `n`，则将获得 `n**2` 根 `Items.Bone`。
例如：
长度 1 => 1 根骨头
长度 2 => 4 根骨头
长度 3 => 9 根骨头
长度 4 => 16 根骨头
长度 16 => 256 根骨头
长度 100 => 10000 根骨头

恐龙帽非常重，所以装备后会使 `move()` 消耗 400 ticks 而不是 200。然而，每当你捡起一颗苹果，`move()` 使用的 ticks 数量便会减少 3%（向下取整），因为尾巴变长可以帮助移动。

以下循环打印出吃掉任意数量苹果后 `move()` 使用的 ticks 数量：

`ticks = 400
for i in range(100):
    print("吃掉 ", i, " 颗苹果后的 ticks: ", ticks)
    ticks -= ticks * 0.03 // 1`

你只有一顶恐龙帽，所以只有一架无人机可以佩戴它。

<spoiler=显示提示 1>如果始终沿着覆盖整个场地的同一路径移动，那么每次都能轻松地得到一条覆盖整个场地的尾巴蛇。虽然效率不高，但确实可行。
完全遍历一个非常大的农场可能需要很长时间，而且你实际上可能并不需要那么多骨头。不妨使用 `set_world_size()` 将农场改为更方便覆盖的大小。</spoiler>

# 扩张 2
你的农场又扩张了！现在地块不再是整齐的一行，所以你需要想办法遍历整个方形网格。

在使用 `while` 循环的情况下，若尚未解锁感官和运算符，则无法实现这一点。
那么是时候介绍 `for` 循环了。

在 [For 循环](docs/scripting/for.md)页面上可以阅读所有有关 `for` 循环的内容，但目前你只需要用它在固定的次数来重复执行代码。

`#做 n 次翻转
for i in range(5):
    do_a_flip()`

`range(n)` 表示一个从 `0` 到 `n-1` 的数字范围，其中包含 `n` 个元素。`for` 循环对序列中的每个元素执行一次循环体。在这个例子中，`do_a_flip()` 将被调用 `5` 次。

现在也可以使用 `get_world_size()` 函数了。它会返回你的农场的边长，即使下次继续扩张你的土地，你所编写的代码也不会失效。

`for i in range(get_world_size()):
    harvest()
    move(North)`

在此示例中，无论农场多大，无人机都会收获农场第一列的每一个格子。

如果想不出来该如何让你的无人机飞遍整个农场，请看下面的提示。
<spoiler=显示提示>当然，有多种方法都可以遍历农场。
我们要找的是一种普遍性的遍历方法，确保代码在农场再次扩大时不会失效。
如果想让你的无人机飞遍整个农场，其中一种普遍性的方法就是永远重复以下两个步骤：

1.向 `North` 移动，直到绕回原点。
2.向 `East` 移动。

`for i in range(get_world_size()):` 可能有助于将这个想法转化为代码。
</spoiler>
<spoiler=显示可能的解决方案> 基础遍历可能如下所示：

`for i in range(get_world_size()):
    for j in range(get_world_size()):
        #在每个地块上翻转一次
        do_a_flip()
        move(North)
    move(East)`
</spoiler>

# 肥料
有些时候，等待植物生长非常影响效率。
与水类似，你每 10 秒会自动获得 1 份肥料，每次升级数量翻倍。

肥料可以使植物加速生长。`use_item(Items.Fertilizer)` 会将无人机下方植物的剩余生长时间缩短 2 秒。

但肥料存在副作用。
施肥生长的植物会被感染。

植物被感染后，收获时一半的产量会变成奇异物质 `Items.Weird_Substance`。
奇异物质也可以用在植物上，其效果是切换该植物及所有相邻植物的感染状态。

所以如果在受感染的植物上调用 `use_item(Items.Weird_Substance)` 会治愈植物，但在健康的植物上调用它，则会感染植物。

如果在有健康邻居的受感染植物上使用它，在治愈该植物的同时会感染邻居，反之亦然。

# 帽子

解锁帽子，现在你获得了几种不同颜色的新帽子，你的无人机现在可以换上新帽子了。

更换帽子的代码如下：
`change_hat(Hats.Gray_Hat)
do_a_flip()
change_hat(Hats.Purple_Hat)
do_a_flip()
change_hat(Hats.Green_Hat)
do_a_flip()
change_hat(Hats.Brown_Hat)
do_a_flip()`

# 排行榜
如果你走到了这一步，说明已经克服了许多挑战。但你的解决方法是否高效？
你可以在各种排行榜上与其他玩家竞争，看看谁的耕作方法效率最高。

调用 `leaderboard_run(leaderboard, filename, speedup)` 即可开始一次排行榜挑战。
这段代码会启动一次类似于 `simulate()` 的[模拟](docs/unlocks/simulation.md)，只不过起始条件是固定的。每个排行榜类别都有不同的开始和成功条件。

如果模拟结束时成功条件为 `True`，则排行榜挑战成功。

当目标达成时，模拟不会自动结束。你必须确保程序终止。
如果挑战成功，你的时间纪录将被添加到排行榜。

为了减少方差，所有挑战都要求运行至少 2 小时（你可以加速，所以实际不会花那么长时间）。如果挑战提前完成，则会重复运行，直到总时间达到 2 小时。随后，将所有运行过程的平均值作为你的分数上传。

以下是示例设置，可以让你登上干草排行榜。
![](LeaderboardSetup400)

## 最快重置
最快重置是最有声望的类别。从一块农田开始，实现游戏完全自动化，直到再次解锁排行榜。

不必解锁全部内容，只需尽快解锁 `Unlocks.Leaderboard`。

请记住，你可以使用 `num_unlocked(unlock) > 0` 来检查某项是否已解锁，也可以对解锁项使用 `get_cost()` 来查看其成本，以便自动耕种正确的物品。

函数调用：
`leaderboard_run(Leaderboards.Fastest_Reset, filename, speedup)`

等效模拟：
`unlocks = {}
items = {}
globals = {}
#负数种子值表示随机种子
seed = -1
simulate(filename, unlocks, items, globals, seed, speedup)`

成功条件：
`num_unlocked(Unlocks.Leaderboard) > 0`

## 迷宫
从解锁全部内容开始，尽快收获 `9863168` 份金币。这正好是重复使用一个 32x32 的迷宫 `300` 次所能获得的金币数量。

函数调用：
`leaderboard_run(Leaderboards.Maze, filename, speedup)`

等效模拟：
`unlocks = Unlocks
items = {Items.Weird_Substance : 1000000000, Items.Power: 1000000000}
globals = {}
seed = -1
simulate(filename, unlocks, items, globals, seed, speedup)`

成功条件：
`num_items(Items.Gold) >= 9863168`

## 恐龙
从解锁全部内容开始，尽快收获 `33488928` 根骨头。这正好是用恐龙尾巴填满一片 32x32 区域所能获得的骨头数量。

函数调用：
`leaderboard_run(Leaderboards.Dinosaur, filename, speedup)`

等效模拟：
`unlocks = Unlocks
items = {Items.Cactus : 1000000000, Items.Power: 1000000000}
globals = {}
seed = -1
simulate(filename, unlocks, items, globals, seed, speedup)`

成功条件：
`num_items(Items.Bone) >= 33488928`

## 其他资源排行榜
每种植物都有自己的排行榜，标准是尽快收获该特定植物。开局获得所有解锁项、种植该植物所需的资源，以及大量的能量。目标是收获该植物产出的特定数量的资源。

与之前一样，你需要确保程序在达到目标时终止。即使目标已达成，只要程序没有结束，挑战就不会完成。

### `Leaderboards.Cactus`
`leaderboard_run(Leaderboards.Cactus, filename, speedup)`
成功条件：`num_items(Items.Cactus) >= 33554432`

### `Leaderboards.Sunflowers`
`leaderboard_run(Leaderboards.Sunflowers, filename, speedup)`
成功条件：`num_items(Items.Power) >= 100000`

### `Leaderboards.Pumpkins`
`leaderboard_run(Leaderboards.Pumpkins, filename, speedup)`
成功条件：`num_items(Items.Pumpkin) >= 200000000`

### `Leaderboards.Wood`
`leaderboard_run(Leaderboards.Wood, filename, speedup)`
成功条件：`num_items(Items.Wood) >= 10000000000`

### `Leaderboards.Carrots`
`leaderboard_run(Leaderboards.Carrots, filename, speedup)`
成功条件：`num_items(Items.Carrot) >= 2000000000`

### `Leaderboards.Hay`
`leaderboard_run(Leaderboards.Hay, filename, speedup)`
成功条件：`num_items(Items.Hay) >= 2000000000`

## 单无人机排行榜
也有单无人机耕作的排行榜。你只有一架无人机和一个 8x8 的农场，并且必须尽快收获特定数量的资源。

### `Leaderboards.Maze_Single`
`leaderboard_run(Leaderboards.Maze_Single, filename, speedup)`
成功条件：`num_items(Items.Gold) >= 616448`

### `Leaderboards.Cactus_Single`
`leaderboard_run(Leaderboards.Cactus_Single, filename, speedup)`
成功条件：`num_items(Items.Cactus) >= 131072`

### `Leaderboards.Sunflowers_Single`
`leaderboard_run(Leaderboards.Sunflowers_Single, filename, speedup)`
成功条件：`num_items(Items.Power) >= 10000`

### `Leaderboards.Pumpkins_Single`
`leaderboard_run(Leaderboards.Pumpkins_Single, filename, speedup)`
成功条件：`num_items(Items.Pumpkin) >= 10000000`

### `Leaderboards.Wood_Single`
`leaderboard_run(Leaderboards.Wood_Single, filename, speedup)`
成功条件：`num_items(Items.Wood) >= 500000000`

### `Leaderboards.Carrots_Single`
`leaderboard_run(Leaderboards.Carrots_Single, filename, speedup)`
成功条件：`num_items(Items.Carrot) >= 100000000`

### `Leaderboards.Hay_Single`
`leaderboard_run(Leaderboards.Hay_Single, filename, speedup)`
成功条件：`num_items(Items.Hay) >= 100000000`

# 迷宫
通过给植物[施肥](docs/unlocks/fertilizer.md)获得的 `Items.Weird_Substance` 对灌木有奇怪的效果。如果在无人机位于灌木上方时调用 `use_item(Items.Weird_Substance, amount)`，灌木将长成一个树篱迷宫。
迷宫的大小取决于使用的 `Items.Weird_Substance` 的数量（`use_item()` 调用的第二个参数）。
未升级迷宫时，使用 `n` 份 `Items.Weird_Substance` 将生成一个 `n`x`n` 的迷宫。每次迷宫升级都会使宝藏中的金币数量翻倍，但所需的 `Items.Weird_Substance` 数量也会随之翻倍。
所以若要生成一个全场迷宫：

`plant(Entities.Bush)
substance = get_world_size() * 2**(num_unlocked(Unlocks.Mazes) - 1)
use_item(Items.Weird_Substance, substance)`


出于某种原因，无人机无法飞过树篱，尽管树篱看起来并没有那么高。

树篱中隐藏着一份宝藏。对宝藏使用 `harvest()` 可以获得等于迷宫面积的金币。（例如，一个 5x5 的迷宫将产出 25 份金币。）

如果在其他任何地方使用 `harvest()`，迷宫将直接消失。

如果无人机在宝藏上方，则 `get_entity_type()` 等于 `Entities.Treasure`，在迷宫的其他地方则等于 `Entities.Hedge`。

除非重复使用迷宫（关于如何重复使用迷宫，请见下文），否则迷宫不包含任何循环。因此，无人机不可能在不回头的情况下再次到达相同的位置。

你可以通过尝试穿过墙壁来检查是否有墙。
`move()` 如果成功则返回 `True`，否则返回 `False`。

`can_move()` 可以用来在不移动的情况下检查是否有墙。

如果不知道如何到达宝藏所在处，请看提示 1，其中说明了如何处理这样的问题。

在迷宫中的任何地方使用 `measure()` 都会返回宝藏的位置。
`x, y = measure()`

为了增加挑战，你也可以通过在宝藏上再次使用相同数量的 `Items.Weird_Substance` 来重复使用迷宫。
这将使宝藏中的金币增加一个完整迷宫份的量，并将其移动到迷宫中的一个随机位置。

每次宝藏被移动时，迷宫中的一些墙壁可能会被随机移除。所以重复使用的迷宫可能包含循环。

请注意，迷宫中的循环会显著提升难度，因为循环意味着你可以在不回头的情况下再次到达相同的位置。
重复使用迷宫得到的金币也并不会比直接收获并生成一个新迷宫更多。
这百分百是一个可以直接跳过的额外挑战。
只有当额外的信息和捷径能帮助你更快地破解迷宫时，才值得重复使用迷宫。

宝藏最多可以被重新定位 300 次。之后，在宝藏上使用奇异物质将不再增加其中的金币，并且它将不再移动。

<spoiler=显示提示 1>以下是解决这个问题的一种通用方法：

创建一个迷宫，并想象你是无人机。

思考一下如果你在迷宫中会如何尝试找到宝藏。

一步步写下你的策略，清晰到可以让其他人不加思考地照办。

现在尝试将你的步骤翻译成代码。
</spoiler>
<spoiler=显示提示 2>只要没有循环，那么所有的墙壁实际上只是一长串的相连墙壁。如果沿着墙走，就会走遍整个迷宫。
这种方法需要编写的代码很少，而且不必记录已经去过的地方。大约 10 行代码就足够了。</spoiler>
<spoiler=显示提示 3>与其让无人机朝东西南北这样的绝对方向移动，朝相对方向（如“右转”或“左转”）移动可能更加实用。为此，你需要记录无人机当前移动的方向。无人机实际上从不旋转，但你仍然可以在代码中保持“虚拟”的旋转。
下面的索引技巧对此很有帮助：

`directions = [North, East, South, West]
index = 0`

使用 `% 4` 来让无人机“绕圈”旋转，这样在 `West` 之后它会绕回到 `North`。
`# 右转
index = (index + 1) % 4`

`# 左转
index = (index - 1) % 4

move(directions[index])`</spoiler>
<spoiler=显示提示 4>如果无法破解也不必为难自己，你始终可以选择效率更低的方式。
破解一个 `1`x`1` 的迷宫总归是小菜一碟。</spoiler>

# 巨型农场
这个极其强大的解锁项让你能够使用多架无人机。

和以前一样，一开始只有一架无人机。额外的无人机必须先被生成，且程序终止后便会消失。
每架无人机运行的都是自己独立的程序。新无人机可以使用 `spawn_drone(function)` 函数生成。

`def drone_function():
    move(North)
    do_a_flip()

spawn_drone(drone_function)`

以上代码会在运行 `spawn_drone(function)` 命令的无人机所在位置生成一架新的无人机。新无人机随后开始执行指定的函数，完成后便会自动消失。

无人机之间不会相互碰撞。

使用 `max_drones()` 获取可同时存在的无人机数量上限。
使用 `num_drones()` 获取农场上已有的无人机数量。


## 示例：
`def harvest_column():
    for _ in range(get_world_size()):
        harvest()
        move(North)

while True:
    if spawn_drone(harvest_column):
        move(East)`

这段代码会让你的第一架无人机水平移动，并生成更多的无人机。生成的无人机将垂直移动并收获其路径上的一切资源。

如果生成的无人机数量已达上限，`spawn_drone()` 将什么也不做并返回 `None`。

以下是另一个为每架无人机传递不同方向的示例。
`for dir in [North, East, South, West]:
    def task():
        move(dir)
        do_a_flip()
    spawn_drone(task)`

## 所有无人机都一样
没有所谓的“主”无人机。所有无人机都可以生成其他无人机，且都计入无人机数量上限。所有无人机在终止时都会消失。如果第一架无人机提前完成程序，另一架无人机将成为通过代码高亮显示其执行过程的无人机。所有无人机都可以触发断点，当一架无人机触发断点时，代码高亮会切换到该无人机。

<spoiler=显示提示>这个并行 `for_all` 函数超级实用，可接受任何函数并在每个农场地块上运行。它会利用所有可用的无人机来做到这一点。

`def for_all(f):
    def row():
        for _ in range(get_world_size()-1):
            f()
            move(East)
        f()
    for _ in range(get_world_size()):
        if not spawn_drone(row):
            row()
        move(North)

for_all(harvest)`

一个特别有用的模式是，如果有可用的无人机就生成一架，没有就自己执行。

`if not spawn_drone(task):
    task()`
</spoiler>

## 等待另一架无人机
使用 `wait_for(drone)` 函数来等待另一架无人机完成。你在生成无人机时会收到 `drone` 句柄。
`wait_for(drone)` 返回另一架无人机正在运行的函数的返回值。

`def get_entity_type_in_direction(dir):
    move(dir)
    return get_entity_type()

def zero_arg_wrapper():
    return get_entity_type_in_direction(North)
drone = spawn_drone(zero_arg_wrapper)
print(wait_for(drone))`

请注意，生成无人机需要时间，所以不建议为每件小事都生成一架新的无人机。

你可以用 `has_finished(drone)` 来看看无人机是不是已经完成了，不用等。

## 无共享内存
每架无人机都有自己的内存，不能直接读取或写入另一架无人机的全局变量。

`x = 0

def increment():
    global x
    x += 1

wait_for(spawn_drone(increment))
print(x)`

这段代码将打印 `0`，因为新的无人机增加了它自己的全局 `x` 副本的值，但不影响第一架无人机的 `x`。

## 竞态条件
多架无人机可以同时与同一个农场地块交互。如果两架无人机在同一个 tick 内与同一个地块交互，两个交互都会发生，但结果可能会因交互的顺序而异。

例如，想象无人机 `0` 和 `1` 都在同一棵即将完全成熟的树上方。
无人机 `0` 调用
`use_item(Items.Fertilizer)`
无人机 `1` 调用
`harvest()`

如果两个操作同时发生，树将先被施肥再被收获。在这种情况下，你将从中获得木材。但是，如果无人机 `1` 稍微快一点，就会在给树施肥前执行收获，也因此不会得到木材。
这就是所谓的“竞态条件”，属于并行编程中的一个常见问题，结果取决于操作执行的顺序。

多架无人机同时在同一位置运行相同代码时，还有可能发生以下问题。
`if get_water() < 0.5:
    use_item(Items.Water)`

如果多架无人机同时运行这段代码，则会都运行第一行，从而进入 `if` 块，接着又都会使用水，导致浪费大量的水。
当一架无人机执行到第二行时，`get_water()` 可能不再小于 `0.5`，因为另一架无人机在此期间已经给地块浇了水。

# 种植
草会自动生长，这很好。所有其他植物都需要调用 `plant()` 函数进行种植。你现在唯一能种的植物是灌木。
你可以像这样把你想种的植物类型传递给函数：

`plant(Entities.Bush)`

这会在无人机下方的地块上种植 1 丛灌木。

调用 `clear()` 函数可以将农场重置为整片草地，并重置无人机回到 (0,0) 的位置。

当农场上同时生长着多种植物时，可能会提高产量。你需要研究混合种植以了解更多信息。

# 混合种植
你可能已经注意到，有时植物种在一起时的产量会更高。
草、灌木、树和胡萝卜在有合适的“伴生植物”时产量更高。每个植物的伴生偏好都不同，这是随机的，无法预测。还好，无人机下方地块上的植物的伴生属性可以通过调用 `get_companion()` 函数来获取。结果会返回一个元组，其中第一个元素是植物想要的伴生植物类型，第二个元素则是它想要伴生植物种下的位置（坐标）。

`plant_type, (x, y) = get_companion()`

例如，如果你在种植一丛灌木后调用 `get_companion()` 函数，就会返回类似 `(Entities.Carrot, (3, 5))` 的结果，表示这丛灌木希望 `(3,5)` 的位置长出胡萝卜。所以如果你在 `(3,5)` 处种植胡萝卜后再收获这丛灌木，它会产出更多的木材。胡萝卜的成熟度不会影响这丛灌木的产量，只要在 `(3,5)` 处种植胡萝卜，这丛灌木的产量就会增加。

具有伴生属性的植物种类只有 `Entities.Grass`、`Entities.Bush`、`Entities.Tree` 和 `Entities.Carrot` 这四种。每个植物都会随机选择与自身种类不同的植物作为伴生对象；伴生对象的坐标也会随机出现在除自己以外的周围三步格子的范围内。请注意：无人机超出边界后会自动折返，这也是一样的，也许你会发现在 `(0,0)` 处获取的信息时，伴生对象的坐标出现在了农场的另一边，实际上这是在反方向的三步以内。

如果无人机下方没有具有伴生偏好的植物，调用 `get_companion()` 函数将返回 `None`。

在混合种植解锁之前，产量乘数是 `5`，之后每次升级倍率都会增加。

# 南瓜
[南瓜](objects/pumpkin)像胡萝卜一样生长在耕过的土地上。种植南瓜需要消耗胡萝卜。

当方形区域内所有的南瓜都完全成熟时，它们会长到一起，合并成 1 个巨型南瓜。不幸的是，南瓜在完全成熟后，有 20% 的几率枯死，南瓜会变为枯萎南瓜，枯萎南瓜不会参与合并行为，并且会阻止合并行为，所以如果想让周围的南瓜合并，需要重新种植新的南瓜，代替枯萎南瓜。

南瓜在枯萎时会留下枯萎南瓜，收获时不会掉落任何东西。在枯萎南瓜的位置上种植新植物会自动将枯萎南瓜移除，所以不必收获枯萎南瓜。请注意： `can_harvest()` 在枯萎南瓜上始终返回 `False`。

巨型南瓜的产量取决于南瓜的大小。

1 个 1 * 1 的南瓜会产出 `1*1*1 = 1` 个南瓜。
1 个 2 * 2 的南瓜会产出 `2*2*2 = 8` 个南瓜，而不是 `4` 个。
1 个 3 * 3 的南瓜会产出 `3*3*3 = 27` 个南瓜，而不是 `9` 个。
1 个 4 * 4 的南瓜会产出 `4*4*4 = 64` 个南瓜，而不是 `16` 个。
1 个 5 * 5 的南瓜会产出 `5*5*5 = 125` 个南瓜，而不是 `25` 个。
1 个 `n` * `n` 的南瓜在 `n >= 6` 时会产出 `n*n*6` 个南瓜。

所以，最佳的南瓜种植大小是 6 * 6 这样获得的南瓜产量是最大的。

如果你在方形区域的每个地块上都种上南瓜，只要其中有一个南瓜变为枯萎南瓜就会阻止巨型南瓜的合并。

# 感官
无人机现在拥有视觉能力了！

调用 `get_pos_x()` 和 `get_pos_y()` 函数会返回无人机当前的 x 和 y 坐标。在起始位置时，返回的都是 `(0,0)` 。x 的坐标向 `East` （右）方向每格增加 `1`，y 的坐标向 `North` （上）方向每格增加 `1`。

调用 `num_items(item)` 函数会返回你现在拥有某种物品的数量。
例如，调用 `num_items(Items.Hay)` 函数就会返回你现在拥有的干草数量。

调用 `get_entity_type()` 和 `get_ground_type()` 函数会返回无人机当前下方实体或地块类型。

如果在灌木上方，就翻转一次：
`if get_entity_type() == Entities.Bush:
    do_a_flip()`

`None` 关键字现在也解锁了！`None` 是一个表示没有值的值。
例如，调用一个没有 `return` 语句的函数实际上就会返回 `None`。

如果无人机下方没有实体，调用 `get_entity_type()` 函数会返回 `None`。


如果想知道你现在拥有的某个特定科技树项目的数量，可以调用 `num_unlocked(unlock)` 函数。

例如，调用 `num_unlocked(Unlocks.Speed)` 函数会返回你现在拥有的速度的等级。

如果感官已解锁，调用 `num_unlocked(Unlocks.Senses)` 函数会返回 `1`，否则返回 `0`。

你也可以对物品、实体或地块调用 `num_unlocked()` 函数，已解锁会返回 `1`，否则返回 `0`。

请注意：调用 `num_unlocked(Unlocks.Carrots)` 函数会返回胡萝卜是否被解锁或者胡萝卜当前的等级。
调用 `num_unlocked(Items.Carrot)` 函数则只会返回 `0` 或 `1`。（其他植物也一样）

# 模拟

模拟可以让你快速测试代码，而不会改变真实农场的状态。
模拟的起始状态可以自由选择，当模拟结束时，真实农场将恢复到模拟开始前的确切状态。

调用 `simulate()` 函数来开始一次模拟。

指定执行的起始文件
`filename = "f1"`

以所有科技树项目全部解锁并全部满级的状态开始
`sim_unlocks = Unlocks`

以 10000 根胡萝卜和 50 捆干草开始
`sim_items = {Items.Carrot : 10000, Items.Hay : 50}`

以一个值为 13 的全局变量 "a" 开始
`sim_globals = {"a" : 13}`

使用固定的随机种子
`seed = 0`

将模拟速度提高到 64 倍
`speedup = 64`

运行模拟程序
`run_time = simulate(filename, sim_unlocks, sim_items, sim_globals, seed, speedup)`

调用 `simulate()` 函数会返回模拟给定起始文件所花费的时间（以秒为单位）。

### 文件名
`simulate()` 函数的第一个参数是文件名，即显示在代码窗口顶部的名称。模拟将运行指定的文件，就像你点击了它的执行按钮一样。

### 起始科技树项目
所有的编程功能，如循环、if 语句、列表、字典……将始终保持解锁状态。

第二个参数可用来指定模拟开始时，除了编程功能外，还需要知道科技树项目解锁/升级哪些内容。该参数必须是一个科技树项目序列。模拟将以序列中所有科技树项目都升级到最高等级的状态开始。

如果想指定非最高级的升级等级，可以传递一个将科技树项目映射到解锁等级的字典。在这种情况下，负值对应于最高解锁等级。

### 起始物品
第三个参数可用来传递一个将物品映射到数量的字典，从而指定模拟开始时拥有的物品数量。

### 起始全局变量
由于模拟开始的是一次全新的程序执行，所以无法访问启动模拟的程序中的变量。
但是，第四个参数可以用来将值传递给模拟。这是一个将字符串形式的变量名映射到值的字典。这些变量随后会被添加到模拟内部执行的全局作用域中。

请注意，这会复制所有值，所以在模拟内部修改它们不会影响模拟外部的原始值。除了运行所需的时间外，无法从模拟中返回其他值。

### 随机种子
第五个参数可以用来指定模拟中使用的随机种子。这必须是一个正整数。负值将导致使用随机种子。

随机种子会影响方方面面的参数，从植物生长时间到迷宫布局再到水分蒸发时间等等。如果使用相同的随机种子和相同的起始条件多次开始同一个模拟，结果应该始终是一样的。

### 加速
第六个参数是模拟的起始速度倍率，以便快速完成测试。如果游戏跟不上设定的速度，则会自动减速。

加速不会以任何方式影响模拟的结果。它的存在只是为了减少等待时间。

# 速度升级
现在，无人机的执行速度翻倍了！但是无人机收获的速度比草生长的速度还快，这会导致根本没有收成。为了解决这个问题，现在解锁了 [if](docs/scripting/if.md) 分支和 [can_harvest](functions/can_harvest) 函数。

## 在收获前检查
到目前为止，我们只用 `True` 和 `False` 作为条件，这对于 `if` 来说用处不大。

调用新的 `can_harvest()` 函数会返回当前无人机下方的植物是否可以被收获，如果植物成熟，则可以被收获返回 `True`，否则返回 `False`。

`if can_harvest():
    #做点什么`

它的返回结果可以被作为一个条件进行判断操作，是因为它会返回一个布尔值。

调用某个函数，得到的结果被称为返回值。

当上面的代码运行时会发生什么：
    -运行 if 语句
    -调用 `can_harvest()`
    -`can_harvest()` 执行其功能
    -`can_harvest()` 返回 `True` 或 `False`
    -语句现在变成了 `if True:` 或 `if False:`
    -只有在可以收获时，才会执行代码块

现在我们可以使用 `if` 语句来防止无人机在下方植物未成熟时提前收获的情况。

# 向日葵
[向日葵](objects/sunflower)会收集太阳的能量，而你可以收获那种能量。

种植向日葵的方式与种植胡萝卜或南瓜完全相同，只不过收获的不再是某种果实，而是能量。

收获 1 株成熟的向日葵会产出能量。
如果农场上至少有 10 株向日葵时，并且你收获了花瓣数量最多的那一株，则将获得 `5` 倍的能量！

`measure()` 返回无人机下方那株向日葵的花瓣数量。
向日葵最少有 `7` 片花瓣，最多有 `15` 片。
花瓣数量在向日葵完全成熟之前就可以测量了。

几株向日葵可能拥有相同数量的花瓣，因此也可能不止一株向日葵的花瓣数量是最多的。在这种情况下，无论收获哪一株都一样。

只要有能量，无人机就会以两倍的速度运行。
无人机每 30 次行动（如移动、收获、种植……）消耗 1 点能量。
执行其他代码语句也会消耗能量，但比无人机行动少得多。

总的来说，所有可以通过提升速度来加速的东西都可以使用能量进行加速。
在不考虑速度倍率的情况下，任何使用能量加速的东西消耗的能量都与执行时间成正比。


# 计时
如果想要进一步优化你的方案，你需要了解这款游戏中时间的计量方式，也就是这个科技树的内容。

## 新函数
如果要考虑事情花费的时间，有两个函数可用：

调用 `get_time()` 函数会返回丛游戏开始以来的时间，单位是秒。

调用 `get_tick_count()` 函数会返回该程序从开始到结束时所占用的 tick 数。

这两个函数以及 `quick_print()` 函数不占用 tick，甚至连调用它们的操作也不占用 tick。

## 运行时详情

### 注意
这是我们为这款游戏制定的一个易于理解且一致的计时模型，这与现实世界中的执行方式是不一样的。
你可能只有在想要极致优化代码时才会关心这个。


代码执行的基本时间单位被称为 "tick" 。在没有速度升级和能量的情况下，执行速度为 `400 ticks/s` 。

通常，组合两个值的操作（例如 `+, -, *, /, //, %, and, or, ...`）占用 1 tick 来运行。
单值 `-` 和 `not` 是不占用 tick 的。
单个 `if` 分支占用 1 tick 来运行（不包括计算条件表达式所需的时间）。
函数调用以及变量的读取和写入不占用 tick ，但函数的定义将占用 1 tick。
`import` 不占用 tick。
使用 `.` 运算符访问导入的模块不占用 tick。
如果一个函数或模块是通过参数或变量赋值传递的，则使用时将占用 1 tick 而非不占用 tick。
`for` 和 `while` 循环开始时占用 1 tick，但迭代自身不占用 tick（不包含条件或者序列表达式所占用的 tick ）。
`return`、`break` 和 `continue` 都不占用 tick。
`pass` 占用 1 tick，所以它可以用来创造精确的延迟。
使用索引运算符对数据结构进行索引占用 1 tick，而在涉及字典或集合的情况下，还需要根据 `key` 的大小占用额外的 tick。

执行内置函数所占用的 tick 在每个函数的文档中都有单独说明。

# 树
[树](objects/tree)是比灌木获取的木材效率更高。每棵树能提供 5 份木材。它们和灌木一样，可以种植在草地或耕过的土地上。

树喜欢保持一定的空间，相邻的两棵树生长速度会减慢。每在其正北、正东、正西或正南方向地块上种植一棵树，都会使其生长时间翻倍。所以如果在每个地块上都种上树，它们的生长时间将是原来的 `2*2*2*2 = 16` 倍。

<spoiler=显示>此时 `%` 运算符或许可以派上用场。记住，`%` 运算符会返回除法的余数。偶数除以 `2` 的余数是 `0`，奇数除以 `2` 的余数是 `1`。
所以你可以像这样检查一个数是否是偶数：

`def is_even(n):
    return n % 2 == 0`

如果 n 是偶数，返回 `True`，否则返回 `False`。
</spoiler>

